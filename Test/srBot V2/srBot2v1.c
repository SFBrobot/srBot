#pragma config(Sensor, in1,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    goalPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  lDriveEnc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rDriveEnc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  stackEnc,       sensorQuadEncoder)
#pragma config(Motor,  port1,           intake,        tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           bblWheel,      tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           tblWheel,      tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           flWheel,       tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           lift,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           goal,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           frWheel,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port8,           tbrWheel,      tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           bbrWheel,      tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port10,          stack,         tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Systems
Drive - 6 Motors
DR4B - 2 Motors
Intake - 1 Motor
Mobile Goal Intake - 0 Motors
Mobile Goal Lift - 2 Motors
Cone Stacker - 1 Motor
*/

#define setDriveR(pwr) motor[bbrWheel] = \
	motor[tbrWheel] = \
	motor[frWheel] = \
	pwr

#define setDriveL(pwr) motor[bblWheel] = \
	motor[tblWheel] = \
	motor[flWheel] = \
	pwr

#define setLift(pwr) motor[lift] = pwr

#define setGoal(pwr) motor[goal] = pwr

#define setIntake(pwr) motor[intake] = \
	pwr

#define setStack(pwr) motor[stack] = \
	pwr

	
//CONSTANTS
const char STICK_THRESH = 11;

enum Power { lDrive = 0, rDrive = 1, lift = 2, stack = 3, intake = 4, goal = 5 };


	
task main() {
	
	short sticks[4];
	int mtrPwrs[6],
		pwrsLast[6] = { 0, 0, 0, 0, 0, 0 };
	
	/*
	0 - left drive
	1 - right drive
	2 - lift
	3 - stack
	4 - intake
	5 - goal
	*/
	
	while(true) {
		for(int i = 0; i < sizeof(sticks) / sizeof(short); i++) {
			
			if(fabs(vexRT[i]) > STICK_THRESH)
				sticks[i] = vexRT[i];
			else
				sticks[i] = 0;
			
		}
		
		mtrPwrs[lDrive] = (sticks[2] + sticks[3]);
		mtrPwrs[rDrive] = (sticks[2] - sticks[3]);
		
		if(vexRT[Btn5U] ^ vexRT[Btn5D]) {
			if(vexRT[Btn5U])
				mtrPwrs[lift] = 127;
			}
			else {
				mtrPwrs[lift] = -127;
			}
		}
		else {
			mtrPwrs[lift] = upPid(&liftPid, SensorValue[liftPot]);
		}
		
		if(vexRT[Btn6U] ^ vexRT[Btn6D]) {
			if(vexRT[Btn6U])
				mtrPwrs[intake] = 127;
			}
			else {
				mtrPwrs[intake] = -127;
			}
		}
		else {
			mtrPwrs[intake] = 0;
		}
		
		if(vexRT[Btn8U] ^ vexRT[Btn8D]) {
			if(vexRT[Btn8U])
				mtrPwrs[goal] = 127;
			}
			else {
				mtrPwrs[goal] = -127;
			}
		}
		else {
			mtrPwrs[goal] = 0;
		}
		
		if(vexRT[Btn8R] ^ vexRT[Btn8L]) {
			if(vexRT[Btn8R])
				mtrPwrs[stack] = 127;
			}
			else {
				mtrPwrs[stack] = -127;
			}
		}
		else {
			mtrPwrs[stack] = 0;
		}

		
	}
}
